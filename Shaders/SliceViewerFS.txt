#version 120

#define MFE_FEATURECOUNT 6
#define MFE_PROPERTYCOUNT 4

#extension GL_ARB_texture_rectangle : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform sampler3D volume;
uniform vec3 volumeOrigin;
uniform vec3 volumeSize;
uniform float volumeDataShift;
uniform float volumeDataScale;

uniform float viewportX;
uniform float viewportY;
uniform int objectId;

uniform float kernelSize;

struct FeatureVector
{
	float v[MFE_PROPERTYCOUNT];
};

struct Feature
{
	bool enabled;
	vec3 examplePos;
	FeatureVector example;
	FeatureVector weights;
	float startThreshold;
	float endThreshold;
	float power;
	vec3 color;
};

uniform Feature userFeatures[MFE_FEATURECOUNT];
uniform int numActiveFeatures;

FeatureVector getFeatureVector(vec3 pos)
{
	FeatureVector result;

	vec4 tpos = gl_TextureMatrixInverse[0] * vec4(pos, 1.0);
	vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin) / volumeSize;
	vec4 comps = vec4(volumeDataShift) + 
		volumeDataScale * texture3D(volume, p);
	for (int i = 0; i < 4; ++i)
	{
		if (i < MFE_PROPERTYCOUNT) result.v[i] = comps[i];
	}

	return result;
}

float distance(FeatureVector a, FeatureVector b, 
	FeatureVector weights, float power)
{
	float sum = 0.0;
	for (int i = 0; i < MFE_PROPERTYCOUNT; ++i)
	{
		sum += pow(weights.v[i] * abs(a.v[i] - b.v[i]), power);
	}
	return pow(sum, 1.0/power);
}

float getValue(Feature f, FeatureVector fv)
{
	// Compute distance
	return distance(fv, f.example, f.weights, f.power);
}

float getValue(Feature f, vec3 pos)
{
	// Get FeatureVector
	FeatureVector fv = getFeatureVector(pos);
	// Compute distance
	return getValue(f, fv);
}

bool isInside(Feature f, float val)
{
	return f.startThreshold <= f.endThreshold ? 
		(val > f.startThreshold && val < f.endThreshold) :
		(val < f.endThreshold || val > f.startThreshold);
}

float dotTexture(vec2 c)
{
	return length(mod(c, 20.0) - vec2(10.0)) < 5.0 ? 0.0 : 1.0;
}

vec3 getVector(FeatureVector fv)
{
	// TODO: use actual transformation to reconstruct the vector direction
	return vec3(
		5.0 + fv.v[0] * -0.608 + fv.v[1] * 1.283 + fv.v[2] * 0.015, 
		fv.v[0] * -1.836 + fv.v[1] * -0.542 + fv.v[2] * 0.048, 
		fv.v[0] * -0.217 + fv.v[1] * -0.061 + fv.v[2] * -0.006);
}

void main()
{
	// Screen coords
	vec2 sc = gl_FragCoord.xy;
	sc.x -= viewportX;
	sc.y -= viewportY;

	// Sample volume
	vec3 pos = gl_TexCoord[0].xyz;

	FeatureVector fv = getFeatureVector(pos);
	vec3 vector = getVector(fv);

	// Color code direction
	vec4 color;
	color = vec4(normalize(vector) + vec3(0.5), 1.0);

	vec3 dir = normalize(vector);
	vec2 d = dir.xy;
	int n = 0;
	float f = 0.0;
	for (int i = 0; i < 100; ++i)
	{
		vec2 tc = sc + float(i - 25) * d;
		f += dotTexture(tc);
		++n;
	}
	f /= float(n);
	color.rgb *= f;

	// Include magnitude
	float magnitude = length(vector) / (volumeDataScale * 0.5);
	color.rgb = vec3(0.3) + vec3(0.7 * clamp(magnitude, 0.0, 1.0)) * color.rgb;

	// Visualize features
	Feature features[MFE_FEATURECOUNT];
	for (int f = 0; f < MFE_FEATURECOUNT; ++f)
	{
		// Copy feature definition
		if (f < numActiveFeatures)
		{
			features[f] = userFeatures[f];
		}
		else
		{
			features[f].enabled = false;
		}

		// Compute examples
		if (features[f].enabled)
		{
			features[f].example = 
				getFeatureVector(features[f].examplePos);
			
			float value = getValue(features[f], fv);
			if (isInside(features[f], value))
			{
				color.rgb = mix(color.rgb, features[f].color, 0.7);
				// TODO: contours might be nice
			}
		}
	}

	// Use black for positions outside the volume
	vec3 tc = (pos - volumeOrigin) / volumeSize;
	for (int i = 0; i < 3; ++i)
	{
		if (tc[i] < 0.0 || tc[i] > 1.0)
		{
			color = vec4(vec3(0.0), 1.0);
		}
	}

	// Pre-multiply alpha and return
	gl_FragColor = vec4(color.rgb * color.a, color.a);
}
