#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform int viewportWidth;

uniform sampler3D volume;
uniform vec3 volumeOrigin;
uniform vec3 volumeSize;
uniform float volumeDataShift;
uniform float volumeDataScale;

struct FeatureVector
{
	float v[MFE_PROPERTYCOUNT];
};

struct Mask
{
	bool v[MFE_ORIGINALPROPERTYCOUNT];
};

struct FeatureDefinition
{
	bool enabled;
	vec3 examplePos;
	float startThreshold;
	float endThreshold;
	float power;
	float stretch;
	vec3 color;
	Mask mask;
	vec3 backgroundPos;
	bool biasRelativeToMean;
};

uniform float dataTransform[MFE_PROPERTYCOUNT * MFE_ORIGINALPROPERTYCOUNT];
uniform float dataMean[MFE_ORIGINALPROPERTYCOUNT];
uniform float dataMin[MFE_ORIGINALPROPERTYCOUNT];
uniform float dataMax[MFE_ORIGINALPROPERTYCOUNT];
uniform FeatureDefinition userFeature;

struct Feature
{
	int defId; // index into the userFeatures uniform
	FeatureVector example;
	FeatureVector bias;
	float delta;
};

FeatureVector getFeatureVector(vec3 pos)
{
	FeatureVector result;

	vec4 tpos = vec4(pos, 1.0);
	vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin) / volumeSize;
	vec4 comps = vec4(volumeDataShift) + 
		volumeDataScale * texture3D(volume, p);
	for (int i = 0; i < 4; ++i)
	{
		if (i < MFE_PROPERTYCOUNT) result.v[i] = comps[i];
	}

	return result;
}

void main()
{
	vec2 coord = gl_FragCoord.xy;
	int x = int(floor(
		coord.x * float(MFE_ORIGINALPROPERTYCOUNT) / 
		float(viewportWidth)));

	FeatureVector fv = getFeatureVector(userFeature.examplePos);
	// Project the featurevector to the original space
	float v = 0.0;
	for (int i = 0; i < MFE_PROPERTYCOUNT; ++i)
	{
		v += fv.v[i] * dataTransform[x + i * MFE_ORIGINALPROPERTYCOUNT];
	}
	// Add the mean
	float mean = dataMean[x];
	v += mean;

	float min = dataMin[x];
	float max = dataMax[x];

	v = (v - min) / (max - min);

	gl_FragColor = vec4(mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.5, 0.0), v), 1.0);
}
