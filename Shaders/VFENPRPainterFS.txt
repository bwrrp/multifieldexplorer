#extension GL_ARB_texture_rectangle : enable
#ifdef GL_EXT_gpu_shader4
#extension GL_EXT_gpu_shader4 : enable
#endif

uniform sampler2DRect infoPrevious;
uniform sampler2DRect infoCurrent;
uniform sampler2DRect normals;
uniform sampler2DRect colors;

uniform int layer;
uniform float viewportX;
uniform float viewportY;
uniform vec3 cameraPos;

uniform sampler3D volume[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataShift[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float volumeDataScale[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeOrigin[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeSize[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform vec3 volumeSpacing[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float tfStart[NQVTK_RAYCASTER_VOLUMECOUNT];
uniform float tfEnd[NQVTK_RAYCASTER_VOLUMECOUNT];

uniform float testParam;

uniform float occlusionEdgeThreshold;
uniform float cornerEdgeThreshold;

// Prototypes from LibUtility
vec3 phongShading(vec3 matColor, vec3 normal);
bool getBit(float byte, int bit);

float stripes(float f, int size, int part) {
	return int(f) % size < part ? 0.0 : 1.0;
}

float plusTexture(vec2 c) {
	return 1.0 - stripes(c.x, 20, 8) * stripes(c.y, 20, 8) * 
		(1.0 - stripes(c.x + 8.0, 20, 4) * stripes(c.y + 8.0, 20, 4));
}

float stripeTexture(vec2 c) {
	return stripes(abs(c.x + c.y), 20, 8);
}

float dotTexture(vec2 c) {
	return length(mod(c, 20.0) - vec2(10.0)) < 5.0 ? 0.0 : 1.0;
}

bool ignoreObject(int id) {
	return id < NQVTK_RAYCASTER_VOLUMECOUNT;
}

void main() {
	// Get info
	vec4 r0 = gl_FragCoord;
	r0.x -= viewportX;
	r0.y -= viewportY;
	vec4 infoBefore = texture2DRect(infoPrevious, r0.xy);
	if (layer == 0) infoBefore = vec4(0.0);
	vec4 infoAfter = texture2DRect(infoCurrent, r0.xy);
	vec4 normalid = texture2DRect(normals, r0.xy);
	vec3 normal = normalize(normalid.rgb);
	float gm = length(normalid.rgb);
	int id = int(normalid.a) - 1;
	vec4 color = texture2DRect(colors, r0.xy);

	// Some extra coloring effects
	if (id == 0) color.a = 0.1;

	// Simple lighting
	if (gm > 0.0) color = vec4(phongShading(color.rgb, normal), color.a);

	// Test: screen-space textures for visualizing ids
	/*
	if (id == 2) {
		color.rgb *= (0.5 + 0.5 * stripeTexture(r0.xy));
	} else if (id == 3) {
		color.rgb *= (0.5 + 0.5 * plusTexture(r0.xy));
	}
	*/

	//* Test: vector direction visualization
	if (id == 1)
	{
		vec4 tpos = gl_TextureMatrixInverse[0] * vec4(infoAfter.rgb, 1.0);
		vec3 p = ((tpos.xyz / tpos.w) - volumeOrigin[0]) / volumeSize[0];
		vec3 dir = vec3(volumeDataShift[0]) + volumeDataScale[0] * texture3D(volume[0], p).xyz;
		dir = gl_NormalMatrix * normalize(dir);
		vec2 d = dir.xy; 
		//vec2 d = (dir - dot(dir, normal) * normal).xy;
		//* Smearing
		int n = 0;
		float f = 0.0;
		for (int i = 0; i < int(100.0 * testParam); ++i)
		{
			vec2 tc = r0.xy + float(i - 25) * d;
			f += dotTexture(tc);
			++n;
		}
		f /= float(n);
		color.rgb *= f;
	}
	//*/

	// Apply contouring
	const int NB_SIZE = 4;
	vec2 nb[NB_SIZE];
	nb[0] = vec2(r0.x - 1.0, r0.y);
	nb[1] = vec2(r0.x + 1.0, r0.y);
	nb[2] = vec2(r0.x, r0.y - 1.0);
	nb[3] = vec2(r0.x, r0.y + 1.0);
	// Collect samples
	int nbIds[NB_SIZE];
	vec3 nbNormals[NB_SIZE];
	vec3 nbPos[NB_SIZE];
	for (int i = 0; i < NB_SIZE; ++i) {
		vec4 normalid = texture2DRect(normals, nb[i]);
		nbIds[i] = int(normalid.a) - 1;
		nbNormals[i] = normalid.rgb;
		nbPos[i] = texture2DRect(infoCurrent, nb[i]).rgb;
	}

	// Premultiply colors
	gl_FragColor = vec4(color.rgb * color.a, color.a);
}
